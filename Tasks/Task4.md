В качестве примера иерархии классов, где применяется принцип открытости-закрытости, рассмотрим систему персонажей из ролевой игры:

## Иерархия классов:

- Character (абстрактный класс) — базовый класс для всех персонажей. Он определяет общие свойства (имя, здоровье, мана, инвентарь) и абстрактный метод attack(). Этот класс закрыт для изменений: его интерфейс и базовая логика не должны изменяться после публикации, чтобы не нарушить работу всей системы.
- Warrior, Mage, Rogue (наследники Character) — конкретные классы персонажей, реализующие свою версию метода attack(). Эти классы открыты для расширения: можно добавлять новые типы персонажей (например, Priest, Hunter), не изменяя код базового класса Character, а только расширяя систему через наследование.

## Обоснование выбора открытых и закрытых классов:

- Character закрыт для изменений, потому что он определяет стабильный контракт (интерфейс) для всех персонажей. Изменение этого класса может привести к ошибкам во всех местах, где он используется.
- Warrior, Mage, Rogue открыты для расширения, потому что добавление новых персонажей (например, с уникальными способностями) не требует изменения существующего кода, а только создания новых подклассов. Это соответствует принципу OCP: классы должны быть открыты для расширения, но закрыты для модификации.


## Вывод
- Если потребуется добавить нового персонажа (например, Paladin), не нужно менять код класса Character или существующих персонажей. Достаточно создать новый класс Paladin, унаследованный от Character, и реализовать нужные методы.
- Такой подход позволяет безопасно развивать проект, не рискуя сломать уже работающий функционал.